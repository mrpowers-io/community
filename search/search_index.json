{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mrpowers-io","text":"<p>This site explains how to grow open source software projects and build codebases that follow best practices.</p> <p>If reflects the collective wisdom of the software developers who build the mrpowers-io software projects.</p> <p>If you develop open source project correctly, then you can create a large community of users and contributors.</p> <p>When your codebase follows software engineering best practices, adding new features is easy.</p> <p>Open source software development doesn't have to be a solitary, thankless grind.</p> <p>You can develop open source software with a great group of maintainers.  Your community with be thankful and grateful for your work when they're properly engaged.</p> <p>We hope you find this site useful in building open source communities with great vibes!</p>"},{"location":"code-best-practices/python/","title":"Python Code Best Practices","text":"<p>This page outlines the best practices for writing Python code in 2024.</p> <p>You will learn about how to expose Python public interfaces, code formatting and linting, and proper typing.</p>"},{"location":"code-best-practices/python/#define-public-interfaces","title":"Define public interfaces","text":"<p>Python codebases should expose end-user functionality via clearly defined public interfaces.</p> <p>The public interfaces should be easy to import.  Let's take a look at how to in the pandas library for example:</p> <pre><code>import pandas as pd\n</code></pre> <p>This import makes it easy to import the public functions like <code>pd.read_parquet</code> or <code>pd.read_csv</code>.</p> <p>Python codebases must only expose the public interface in the documentation.  Don't make the mistake of improperly structuring your code and not clearly defining a public interface.</p>"},{"location":"code-best-practices/python/#python-code-autoformatting-tools","title":"Python Code autoformatting tools","text":"<p>Python codebases can be autoformatted with Black or Ruff.</p> <p>Repos should contain clear instructions on how to autoformat the code via text editor integrations, pre commit hooks, or CI.  The code should be setup so that autoformatting the code is straightforward for all developers.</p> <p>This saves the whole team a lot of wasted effort talking about code styling and from providing code formatting nits in PR reviews.</p>"},{"location":"code-best-practices/python/#python-code-linting","title":"Python Code linting","text":"<p>Ruff is a good tool for linting code.</p> <p>Code linters ensure that code is compliant with PEP8.</p> <p>You should lint all your code and prevent new code from getting merged unless it is properly linted.</p>"},{"location":"code-best-practices/python/#python-type-hints","title":"Python Type hints","text":"<p>Modern Python code should use type hints.</p> <p>Here's an example of a function without type hints:</p> <pre><code>TODO\n</code></pre> <p>Here's the same function with type hints:</p> <pre><code>TODO\n</code></pre> <p>Type hints have a variety of advantages:</p> <ul> <li>make it easier to invoke the function</li> <li>prevent the function from being invoked with inproper arguments</li> <li>provide higher quality documentation for end users with clear inputs and outputs</li> </ul>"},{"location":"code-best-practices/python/#python-build-tools","title":"Python build tools","text":"<p>There are many popular build tools for Python projects like Poetry and TODO.</p> <p>Poetry has nice features and encourages coding best practices.</p> <ul> <li>users can specify different dependency groups</li> <li>dependencies can be listed in the <code>pypoetry.toml</code> file</li> <li>The exact versions of all dependencies and transitive dependencies is specified in the <code>poetry.lock</code> file to allow for deterministic builds</li> <li>nice developer quality of life features like single commands to build wheel files and deploy to PyPI</li> </ul> <p>Using Poetry to properly specify dependencies is better than listing dependencies in a <code>requirements.txt</code> file for the following reasons:</p> <ul> <li><code>requirements.txt</code> files don't specify exact versions of dependencies / transitive dependencies, so builds are not deterministic</li> <li>no quality of life helper functions</li> </ul> <p>You should build your Python projects with a proper build tool.</p>"},{"location":"code-best-practices/python/#python-documentation","title":"Python documentation","text":"<p>You should have well-documented instructions to generate documentation for the public interface of your project.</p> <p>The public facing documentation should provide examples and give users a solid understanding of the functionality provided by your library.</p> <p>The best alternative is a user guide that's generated by humans for a high level overview of the project and programatic generated API documentation with easily accessible details for each component of the public interface.</p>"},{"location":"code-best-practices/python/#limiting-python-dependencies","title":"Limiting Python dependencies","text":"<p>You should limit the number of dependencies and transitive dependencies in your projects, especially if you're building a library.</p> <p>Remember that if you depend on one library which in turn depends on 10 other library, then you have 11 dependencies, not just one dependency.</p> <p>Dependencies can cause dependency hell for end users, so you always need to througoly vet all dependencies.  You also need to analyze all the transitive dependencies that are pulled in and make sure the projects are maintained well for the long term viability of your codebase.</p>"},{"location":"code-best-practices/python/#optional-python-dependencies","title":"Optional Python dependencies","text":"<p>Some dependencies in Python projects can be specified as optional if the funcionality is only relevant for a subset of users.</p> <p>Use optional dependencies whenever possible rather than requiring all users to install all dependencies, even when they're not needed.</p> <p>PyPI has a nice installation process for optional dependencies.  Here's an example of how to install Polars with the optional deltalake dependency:</p> <p>TODO</p> <p>This optional dependency powers the <code>pl.read_delta</code> and <code>pl.scan_delta</code> functionality.  It's only required for Polars users that want to read Delta Lake tables.</p>"},{"location":"code-best-practices/python/#supported-python-versions","title":"Supported Python versions","text":"<p>Your Python library should support Python versions applicable to your users.</p> <p>You can't just support the latest Python version because that will make your code inaccessible to users running older versions of Python.</p> <p>This unfortunately means the Python library developers generally can't use the latest features of Python (unless they've been backported to earlier Python versions).</p>"},{"location":"code-best-practices/python/#python-code-performance","title":"Python code performance","text":"<p>TODO</p>"},{"location":"code-best-practices/python/#python-code-style","title":"Python Code style","text":"<p>There are various Python code style guides that recommend the object oriented/functional programming style, max lines in functions, and max lines in files.</p> <p>You can even quantify the code quality with tools like TODO.</p> <p>Nice code style is preferable, but it's comparatively less important than a clean public interface, a proper number of dependencies, and code that meets performance needs.</p>"},{"location":"governance/mrpowers-io-org/","title":"mrpowers-io GitHub organization","text":"<p>The mrpowers-io GitHub organization is owned by Matthew Powers and Sem Sinchenko (\"org owners\").</p> <p>The org owners are responsible for overseeing projects and reviewing project reports on a quarterly basis.</p>"},{"location":"governance/mrpowers-io-org/#overseeing-projects","title":"Overseeing projects","text":"<p>The org owners are responsible for voting on new projects that will be added in the mrpowers-io organization.</p> <p>The org owners are also responsible for monitoring the projects at a high-level including code quality, documentaion, the README, and repo activity.</p>"},{"location":"governance/mrpowers-io-org/#managing-repo-permissions","title":"Managing repo permissions","text":"<p>The org owners will have to manage repo permissions from time-to-time.</p> <p>The org owners may need to add a new maintainer to a repo if other repo owners don't have permissions, for example.</p>"},{"location":"governance/mrpowers-io-org/#overseeing-package-manager-permissions","title":"Overseeing package manager permissions","text":"<p>Repos in the mrpowers-io organization will often be bundled and distributed via a package manager like Maven, PyPI, or Cargo.</p> <p>Repo maintainers should also have access to make releases via package managers.</p> <p>This ensures the package can continue being published in the event of an extreme event like a hardware failure, losing keys, or getting hacked.</p>"},{"location":"governance/mrpowers-io-org/#quarterly-project-reports","title":"Quarterly project reports","text":"<p>Repo maintainers should submit project reports on a quarterly basis showing key metrics like the number or new contributors, number of new stars, PyPI downloads, etc.</p> <p>The report should explain how the repo maintainers plan to grow the project in the upcoming quarter.</p> <p>The mrpowers-io org is generally for projects that are being actively maintained with maintainers that are ambitiously growing the user base.</p>"},{"location":"governance/mrpowers-io-org/#other-org-matters","title":"Other org matters","text":"<p>The org owners are also responsible for voting in new org owners and strategizing how to get new projects.</p>"},{"location":"governance/mrpowers-io-repos/","title":"mrpowers-io repo management","text":"<p>This page explains how the repos in the mrpowers-io GitHub organization should be managed.</p>"},{"location":"governance/mrpowers-io-repos/#repo-roles","title":"Repo roles","text":"<p>A GitHub repo can assign a user the following roles:</p> <ul> <li>read: can read/clono repo and open/comment on PRs/issues (default permissions for OSS repos anyways)</li> <li>triage: can also manage issues / PRs</li> <li>write: can also push to repo</li> <li>maintain: also have some repo settings</li> <li>admin: have more repo settings and can add collaborators</li> </ul> <p>The repo maintainers should vote on giving access to new members.  They should also nominate new members based on their repo activity and interest.</p>"},{"location":"governance/mrpowers-io-repos/#maintainer-voting","title":"Maintainer voting","text":"<p>Maintainers should vote on GitHub Discussion threads or mailing lists.</p> <p>The proposal should be fully outlined in the Discussion topic.  Stakeholders can respond with a vote from +1 to -1, aligned with Apache expression voting.</p> <p>Community votes are valued, but maintainer votes are all that count for the final decision.</p> <p>Unlike Apache voting which allows for vetos, mrpowers-io voting is majority rules.  But conflicts should be escalated to the mrpowers-io organization owners for resolution.</p>"},{"location":"governance/mrpowers-io-repos/#quarterly-project-reporting","title":"Quarterly project reporting","text":"<p>Projects should report to the mrpowers-io organization owners on a quarterly basis with the following information:</p> <ul> <li>project metrics</li> <li>quick summary of progress in the previous quarter</li> <li>plan for the upcoming quarter</li> </ul> <p>The project metrics can be accumulated programatically usually.</p> <p>The retrospective and plan can be detailed or quick.  The dev teams should demonstrate that they're studying the data, identifying where the project needs to be improved, and allocating effort to the highest ROI activities.</p>"},{"location":"governance/mrpowers-io-repos/#project-license","title":"Project license","text":"<p>Projects should use the Apache or MIT license.</p> <p>The mrpowers-io organization is for open source repos with permissive licenses.</p>"},{"location":"governance/mrpowers-io-repos/#deactivating-maintainers","title":"Deactivating maintainers","text":"<p>Maintainers will become inactive from time-to-time because of sabbaticals, other interests or a change in priorities.</p> <p>Any maintainer that's inactive for some time will be switched to the maintainer alumni bucket and their repo permissions/voting rights will be removed.</p>"},{"location":"governance/mrpowers-io-repos/#deactivating-projects","title":"Deactivating projects","text":"<p>Projects that become deactive for some time will either be transferred to a different GitHub owner or archived.</p> <p>The mrpowers-io organization is for projects that are maintained and have an active user base.</p> <p>It's OK for projects to go into \"maintenance mode\" if there are users and new features don't need to be added anymore.</p>"},{"location":"open-source/chat-apps/","title":"Open-source chat apps","text":"<p>There are a variety of tools open source communities use to chat like Slack, Discord, Matrix, and IRC.</p> <p>The best chat tool depends on accessibility, community preferences, and cost.</p>"},{"location":"open-source/chat-apps/#slack-for-open-source-communities","title":"Slack for open source communities","text":"<p>Slack is a good option for some open source communities, especially when most users are already using the application on a daily basis for their day-job.</p> <p>Slack does have some big downsides:</p> <ul> <li>invitation links expire and need to be refreshed constantly</li> <li>it is very expensive</li> <li>free plan deletes messages older than a month</li> </ul> <p>We should aim to respond to all Slack conversations.  Lots of answers should be to just encourage the users to create a GitHub discussion or send them a link to a blog post.  Slack conversations are more work than GitHub discussions because they\u2019re not indexed by Google and disappear after a month (so the same question keeps getting asked).</p> <p>It\u2019s best to encourage community members to answer Slack questions, so we don\u2019t have to do this work.  We should monitor Slack stats via CommonRoom, identify the top community contributors, and directly encourage them to keep answering questions / give them OSS care packages to say thank you.</p>"},{"location":"open-source/chat-apps/#discord-for-open-source-communities","title":"Discord for open source communities","text":"<p>TODO</p>"},{"location":"open-source/chat-apps/#matrix-for-open-source-communities","title":"Matrix for open source communities","text":"<p>TODO</p>"},{"location":"open-source/chat-apps/#piggybacking-on-existing-open-source-communities","title":"Piggybacking on existing open source communities","text":"<p>TODO</p>"},{"location":"open-source/chat-apps/#conclusion","title":"Conclusion","text":"<p>TODO</p>"},{"location":"open-source/code-best-practices/","title":"Code best practices","text":""},{"location":"open-source/code-best-practices/#open-source-code-best-practices","title":"Open Source Code Best Practices","text":"<p>Project repositories should be exemplary of software engineering best practices.</p> <p>For example, Python repos should be PEP8 compliant, use best linting practices, have a release process built into the CI, have a deterministic build lock file, etc.</p> <p>Your repos should be viewed by the community as an example of modern best practices for Java, Scala, Python, and Rust.</p>"},{"location":"open-source/code-best-practices/#code-formatting","title":"Code formatting","text":"<p>Code should use programmatic formatting tools like black for Python or scalafmt for Scala.</p> <p>PR comments with \"code formatting nits\" have gone out of style ever since Golang shipped gofmt.</p> <p>Machines should format code, not humans.</p>"},{"location":"open-source/code-best-practices/#code-versioning","title":"Code versioning","text":"<p>Code should be versioned with Semantic Versioning 2.0 (\"SemVer\") or Calendar Versioning (\"CalVer\").</p> <p>Make sure to document the code versioning scheme that's used and follow it strictly.</p> <p>Users depend on libraries to avoid breaking changes that are inconsistent with the selected versioning scheme. You need to be a reliable dependency for users, or they'll look for other libraries as options.</p>"},{"location":"open-source/code-best-practices/#continuous-integration-ci","title":"Continuous integration (CI)","text":"<p>Continuous integration refers to automated build systems that run unit tests, code linting, and other checks on code branches.  These checks increase the likelihood of only high-quality code being merged with the main branch.</p>"},{"location":"open-source/code-best-practices/#continuous-deployment-cd","title":"Continuous deployment (CD)","text":"<p>TODO</p>"},{"location":"open-source/code-best-practices/#production-release-process","title":"Production release process","text":"<p>TODO</p>"},{"location":"open-source/code-best-practices/#code-linters","title":"Code linters","text":"<p>TODO</p>"},{"location":"open-source/code-best-practices/#conventional-commits","title":"Conventional commits","text":"<p>TODO</p>"},{"location":"open-source/code-best-practices/#language-specific-code-best-practices","title":"Language-specific code best practices","text":"<p>TODO</p>"},{"location":"open-source/code-best-practices/#code-performance","title":"Code performance","text":"<p>TODO</p>"},{"location":"open-source/code-best-practices/#code-longevity","title":"Code longevity","text":"<p>TODO</p>"},{"location":"open-source/code-best-practices/#avoid-breaking-changes","title":"Avoid breaking changes","text":"<p>TODO</p>"},{"location":"open-source/documentation-best-practices/","title":"Open Source Documentation best practices","text":"<p>SemVer 2.0 says it well:</p> <p>It is your responsibility as a professional developer to properly document software that is intended for use by others. Managing software complexity is a hugely important part of keeping a project efficient, and that\u2019s hard to do if nobody knows how to use your software, or what methods are safe to call.</p> <p>Your project should have documentation that provides a user guide and shows how to use the public interface.</p>"},{"location":"open-source/documentation-best-practices/#user-guide","title":"User guide","text":"<p>Your docs can include a user guide that provides an overview of how to use your project.  This is especially useful for frameworks or complicated projects with a large API surface area.</p> <p>For example, suppose your project is a Java testing framework.  You could create a user guide that explains why testing Java code is important and the basics of testing Java. You could also provide high-level examples of the different types of tests and how to structure a test suite.</p> <p>User guides are a great way to demonstrate how to use a project in real-world applications.</p>"},{"location":"open-source/documentation-best-practices/#api-docs","title":"API docs","text":"<p>The API docs should be programmatically generated directly from the codebase.</p> <p>The codebase should contain docstrings with examples that show how to use each public function.</p> <p>Your project should have a single command that generates the programmatic API docs for all its public functions.  You don't need to document private functions.</p> <p>Spend time to make sure that the programatic API docs are easy to follow and provide extensive minimal examples.</p>"},{"location":"open-source/documentation-best-practices/#versioning-docs","title":"Versioning docs","text":"<p>It can be useful to generate separate versions of the docs for each release (e.g., one version of the API docs for v0.12.0 and another version of the API docs for v0.13.1).</p> <p>Here are two URLs for Apache Iceberg table maintenance documentation for example:</p> <ul> <li>https://iceberg.apache.org/docs/1.5.1/maintenance/</li> <li>https://iceberg.apache.org/docs/1.4.0/maintenance/</li> </ul> <p>One page is for the v1.5.1 release and another page is for the v1.4.0 release.</p> <p>Versioned docs can be great in theory:</p> <ul> <li>they can provide a great user experience for users who want the exact documentation for a specific release</li> </ul> <p>Versioned docs can also be really dangerous:</p> <ul> <li>canonical links: versioned docs create duplicate pages, which is confusing for search engines.  You must add canonical links to let search engines know what page they should rank.  This is critical.</li> <li>maintenance burden: It's hard to maintain multiple versions of doc sites.  If you notice a typo for example, you need to fix the latest version and update all the existing pages with the typo as well.</li> <li>hiding new features: The v1.4.0 docs intentionally exclude new features that were added in v1.5.0.  It may be better for v1.4.0 users to see the v1.5.0 docs, so they are aware of the new features and are motivated to upgrade.  OSS library maintainers generally don't want users stuck on old versions.</li> <li>users must manually specify the right version: Most users end up on docs from Google searches and don't pay close attention to the version.  They don't usually search for the exact version they're using, go to the docs, click the dropdown to the exact version, and then start exploring.  They just go to the first docs page they find from a Google search and immediately look for an answer.</li> </ul> <p>Versioning docs may be a good idea, but versioning the user guide is almost always a bad idea.  There are very few open source software teams with the bandwidth to maintain multiple versions of a user guide and provide customizations for each release.</p>"},{"location":"open-source/documentation-best-practices/#website-best-practices","title":"Website best practices","text":"<p>Software documentation is deployed as a website and needs to follow web best practices, just like any other website.  Some examples:</p> <ul> <li>descriptive h1s, h2s, and URLs</li> <li>HTML structure that's easy for search engines to navigate</li> <li>canonical links for any duplicate pages (especially critical for versioned docs)</li> </ul> <p>You need to follow website conventions to have the right pages rank in searches and to give your users documentation that is easy to navigate.</p>"},{"location":"open-source/documentation-best-practices/#deploying-docs","title":"Deploying docs","text":"<p>You should have a command to deploy the docs in production.</p> <p>You will also ideally have a release process that automatically releases the docs whenever you release a new package.  The documentation deployment process should be part of your continuous integration / continuous deployment process.</p>"},{"location":"open-source/documentation-best-practices/#dont-change-urls","title":"Don't change URLs","text":"<p>Your documentation URLs should not change.  If you ever need to change a page's URL, make sure you set up the proper redirects.</p> <p>Search engines don't like when URLs are changed.  You should only change URLs in rare instances.</p>"},{"location":"open-source/documentation-best-practices/#importance-of-documentation","title":"Importance of documentation","text":"<p>Documentation can make or break a project.</p> <p>Good documentation convinces users to try out a library and then depend on it in production code.</p> <p>Bad docs drive away potential users.</p> <p>You should spend lots and lots of time making beautiful documentation that attracts users.</p>"},{"location":"open-source/easy-onboarding/","title":"Open source easy onboarding","text":"<p>Open-source projects should have an easy onboarding process.</p> <p>Users should be able to get set up locally and use your software in a few minutes.</p> <p>You should spend a lot of time building a seamless onboarding process.  You should continuously refine it and learn how to set up all users in a few minutes.  Make sure that all users have an easy onboarding process, regardless of the operating system.</p>"},{"location":"open-source/easy-onboarding/#great-examples","title":"Great examples","text":"<p>The Polars user guide is a great example of a site that teaches you how to use the DataFrame library quickly.</p> <p>This video on how to build a blog engine in 15 minutes is a great example of how to acquire users with a compelling demo. It propelled Rails as a popular web development framework.</p>"},{"location":"open-source/easy-onboarding/#readme","title":"README","text":"<p>Your project README should explain the commands a user can run to use your project locally.  It should just be a few steps.  Make sure the setup is standard for whatever programming language you're using.</p> <p>In the how to get thousands of stars on your GitHub project article, the author gives some great advice:</p> <p>For every hour of code you write, spend an hour writing your README</p> <p>Spend a lot of time building amazing READMEs.</p>"},{"location":"open-source/easy-onboarding/#docker","title":"Docker","text":"<p>You should also have a Docker image ready for users who don't want to install software locally.</p> <p>Some users will want to download your library from a package manager (like PyPI, Bundler, or Maven), but others will want to simply grab a pre-built Docker image on Dockerhub.</p> <p>Make multiple easy onramps to try out your project.</p>"},{"location":"open-source/easy-onboarding/#example-python-quickstart","title":"Example Python quickstart","text":"<p>Here's an example of a quickstart for the quinn project.</p> <p>Quinn is uploaded to PyPI and can be installed with this command:</p> <pre><code>pip install quinn\n</code></pre> <p>Here's how you can use quinn to validate the presence of columns in a DataFrame:</p> <pre><code>import quinn\n\nquinn.validate_presence_of_columns(source_df, [\"name\", \"age\", \"fun\"])\n</code></pre> <p>The <code>validate_presence_of_columns</code> will throw an error if the DataFrame does not contain the specified columns.</p>"},{"location":"open-source/easy-onboarding/#conclusion","title":"Conclusion","text":"<p>Prospective users will often glance at a README when considering an open source project.</p> <p>If the setup is simple enough, many will be enticed to try your project.</p> <p>If the setup is complicated or the value proposition is not clear, many will click the back button.</p> <p>Make sure to convert README viewers to actual users with compelling localhost setup instructions!</p>"},{"location":"open-source/github-best-practices/","title":"GitHub best practices for open source projects","text":""},{"location":"open-source/github-best-practices/#github-issues-for-open-source","title":"GitHub Issues for open source","text":"<p>We should respond to all GitHub issues in a timely manner (generally within a few days).  There are a variety of actions that can take place after reviewing a GitHub issue:</p> <ul> <li>Convert it to a GitHub Discussion</li> <li>Answer and close it</li> <li>Ask for more details</li> <li>Ask the issue creator if they would like to build the feature</li> </ul> <p>It's best to link PRs to GitHub issues so the work is more trackable.</p> <p>Close issues older than 6 months with a GitHub action.  Let the PR author know they can re-open if it is still valid.</p> <p>Assign issues to team/community members, so it\u2019s clear who is responsible for driving the issue to completion.</p> <p>Be extra kind and supportive of any community member who\u2019s brave enough to open an issue. The issue creator should feel that our community is welcoming and supportive.</p>"},{"location":"open-source/github-best-practices/#github-pull-requests-for-open-source","title":"GitHub Pull Requests for open source","text":"<p>GitHub pull requests should have an assignee (who wrote the code), a reviewer (team member who\u2019s reviewing the PR), and a description with \u201cFixes #issue_numer\u201d that auto-closes the issue when the PR is merged.</p> <p>If the comments become extensive, we should offer to help and push commits to get the PR over the finish line. In general, we don\u2019t want to give open source contributors many rounds of comments.</p>"},{"location":"open-source/github-best-practices/#github-milestones-for-open-source","title":"GitHub Milestones for open source","text":"<p>GitHub issues should be assigned to milestones.  The upcoming milestone should have a date.  We can set the date to whatever we\u2019d like and change it at any time.</p> <p>The GitHub milestones serve as the open source roadmap.  It's cumbersome to manage the roadmap with an external Google Doc or a giant issue.</p> <p>Milestones offer the flexibility necessary for open source project management. When the situation changes, issues can easily be moved to different milestones.</p>"},{"location":"open-source/github-best-practices/#open-source-github-discussions","title":"Open source GitHub Discussions","text":"<p>GitHub discussions are better for Q&amp;A, Ideas, announcements, ideas, polls, and show and tell.</p> <p>It\u2019s easy to convert GitHub issues to GitHub discussions and it\u2019s a really nice tool when triaging issues.</p> <p>GitHub discussions have features that are not available in GitHub issues, so they are an important tool for managing community interactions.</p>"},{"location":"open-source/grow-community/","title":"How to grow open source communities","text":"<p>The community generally refers to the users, maintainers, and code contributors of an open source project.</p> <p>There are different types of community participants:</p> <ul> <li>active participants: engage on Slack, in community meetings, or on GitHub</li> <li>lurkers: join the Slack and/or community meetings, but don't actively engage</li> <li>passive users: simply use the software product and don't even join the communities</li> </ul> <p>As an open source developer, you want to delight all types of users.</p>"},{"location":"open-source/grow-community/#delighting-active-participants","title":"Delighting active participants","text":"<p>Active participants post in chat, comment on social media, and ask questions at community meetings\u2014make sure you always respond!</p> <p>It's frustrating to ask questions and not get an answer.  It's critical to always respond, even if you don't have a good answer.</p> <p>Always encourage active participants to get more involved:</p> <ul> <li>invite them to contribute</li> <li>tell them to respond to other users</li> <li>ask them to present or blog</li> </ul> <p>Active participants love helping out and are a great way to build a community!</p>"},{"location":"open-source/grow-community/#delighting-lurkers","title":"Delighting lurkers","text":"<p>Lurkers follow conversations in chat and monitor GitHub activity, but they don't ever comment.</p> <p>You can make lurkers happy by creating a good community vibe and by outputting a steady stream of insightful content.</p> <p>Lurkers are content consumers and appreciate good blog posts and docs.  Make sure to consistently invite lurkers to become active in Slack or to make PRs in GitHub, so they know that becoming a contributor is an option.</p>"},{"location":"open-source/grow-community/#delighting-passive-users","title":"Delighting passive users","text":"<p>Passive users depend on your software project but don't bother joining the chat or monitoring GitHub.</p> <p>They're just interested in using your library to build their own apps.</p> <p>The best way to delight passive users is to build a bug-free project that provides descriptive error messages, has awesome documentation, and is well-maintained.</p> <p>Passive users don't like when upgrading library versions causes breakages, so avoid making breaking changes at all costs.  Follow semantic versioning strictly if you ever introduce a breaking change.  Always consider building new functionality alongside existing public functions rather than removing the existing functions so your code maintains backward compatibility.  Deprecating is often better than breaking changes.</p>"},{"location":"open-source/grow-community/#community-meetings","title":"Community meetings","text":"<p>Projects should hold community meetings periodically to highlight external project contributions and new features and discuss the roadmap.</p> <p>The meeting frequency should depend on the project's maturity.  A project that\u2019s rapidly incubating may have community meetings on a biweekly basis and a project that\u2019s rather mature may just have the meetings on a quarterly basis.</p> <p>The community meetings should be recorded and posted on YouTube so they\u2019re available to people who can\u2019t attend live.</p> <p>Community meetings will only appeal to a small set of users overall (only the users who have free time and are super interested in the latest developments, even the ones that are not relevant to their job). Attendance for a community meeting will never be super high, but it\u2019s still an important component of community building.</p>"},{"location":"open-source/grow-contributors/","title":"How to acquire open source code contributors","text":"<p>This page explains how you can get more people to commit to your open source project.</p> <p>The community often prefers depending on open projects with a diverse set of contributors over alternatives with only a few committers.</p> <p>Here's the high-level formula for getting contributors:</p> <ol> <li>Building a community with a welcoming vibe</li> <li>Create well-defined chunks of work</li> <li>Outline clear steps for making pull requests</li> <li>Help contributors to get their PRs merged</li> </ol>"},{"location":"open-source/grow-contributors/#good-first-issues","title":"Good first issues","text":"<p>The repo should have many issues with the \"good first issue\" label, with a variety of easy and medium-difficulty tasks. Some tasks should be code contributions, and others should be documentation tasks / trivial fixes.  We always want an easy on-ramp for someone who's making their first OSS contribution.</p>"},{"location":"open-source/grow-contributors/#outline-clear-steps-for-making-pull-requests","title":"Outline clear steps for making pull requests","text":"<p>The repo should contain clear instructions for creating pull requests and any necessary code requirements, such as code style or unit testing.</p> <p>Document all expectations in detail so contributors know exactly what their PR needs for it to be merged.</p> <p>Encouraging contributors to get approval on suggestions in GitHub issues before writing any code is also advisable.  This saves contributors from wasting time on an idea that the maintainers don't want.</p>"},{"location":"open-source/grow-contributors/#help-contributors-push-their-prs-over-the-finish-line","title":"Help contributors push their PRs over the finish line","text":"<p>Maintainers should collaborate with contributors and help them get their PRs ready to be merged.</p> <p>The PR review process isn't an interview, and it's also not an opportunity for a maintainer to show off their knowledge of the subject matter.</p> <p>Open source PRs are an opportunity for maintainers to mentor the community, hopefully inspiring them to be long-term committers.</p> <p>Feel free to provide comments, but don't be overly pedantic.  Some maintainers are too strict on new committers.</p> <p>If necessary, offer to push a commit to the branch to help the PR reach the finish line.  Always thank the committers profusely and encourage them to make more contributions.</p>"},{"location":"open-source/grow-contributors/#respond-quickly","title":"Respond quickly","text":"<p>You should respond quickly whenever a new contributor creates an issue or submits a pull request.</p> <p>It's best to review ASAP, but if that's not possible, it's better to say, \"I am really busy and will try to review this in a couple of weeks,\" than not replying at all.</p> <p>Interfacing with the developer community should be one of the most satisfying and fun parts of being an open source maintainer!</p>"},{"location":"open-source/grow-contributors/#contributingmd-file","title":"CONTRIBUTING.md file","text":"<p>The <code>CONTRIBUTING.md</code> file should be stored in the project root and explain how to contribute to the code repository.  It should generally follow the GitHub guidelines for repository contributors.</p> <p>The Rails CONTRIBUTING.md file is a great example.  It explains how to proceed with various types of issues.</p> <p>The CONTRIBUTING.md file should focus on technical details for making changes to the codebase.  The code of conduct should be outlined in the <code>CODE_OF_CONDUCT.md</code> file.</p>"},{"location":"open-source/grow-contributors/#contributor-meetings","title":"Contributor meetings","text":"<p>Projects should have periodic contributor meetings with the maintainers, contributors, and interested contributors.  Monthly or quarterly is usually a good cadence.</p> <p>The contributor meetings give the valued OSS contributors direct access to the core developers, motivating and encouraging them to participate more.</p> <p>Here are good topics to discuss at the contributor meetings:</p> <ul> <li>issues that can be grabbed</li> <li>open pull requests and next steps</li> <li>blockers</li> <li>project ideas</li> </ul> <p>Chatting with contributors makes them more invested in the project.</p>"},{"location":"open-source/grow-contributors/#build-relationships-with-open-source-contributors","title":"Build relationships with open source contributors","text":"<p>You should try and become friends with the core open source contributors of a project.</p> <p>Friendly vibes between the core contributors make the codebase more fun and create a welcoming vibe for new participants.</p>"},{"location":"open-source/grow-contributors/#create-a-community-with-a-welcoming-vibe","title":"Create a community with a welcoming vibe","text":"<p>It's great to create a channel in a chat app where new participants can introduce themselves to the community when they join.  If you have some extra time, ping these new entrants and tell them you're excited to have them join the community.</p> <p>Do your best to loop in the new participants to an upcoming community meeting and help them get onboarded as users or contributors.</p> <p>Spreading the good vibes is a great way to encourage lurkers to get more involved as well.</p>"},{"location":"open-source/project-metrics/","title":"Open Source Project metrics","text":"<p>Metrics for all projects should be gathered periodically to ensure their growth. Based on these metrics, the maintainer's efforts should be optimized.</p> <p>It's generally best to track project metrics on a monthly basis but quarterly is fine for less active projects.</p> <p>Maintainers should focus on getting new contributors if the number of new committers is lacking.  They should focus on getting more downloads if there are not enough users.</p>"},{"location":"open-source/project-metrics/#specific-metrics","title":"Specific metrics","text":"<p>Here are the project metrics that should be tracked on a monthly basis:</p> <ul> <li>Number of new contributors</li> <li>GitHub stars</li> <li>LinkedIn followers</li> <li>Project downloads</li> <li>Number of open issues/PRs</li> <li>Documentation pageviews</li> </ul> <p>Let's start by talking about why \"gaming\" project metrics are a common objection to collecting them in the first place.</p>"},{"location":"open-source/project-metrics/#gaming-project-metrics","title":"Gaming project metrics","text":"<p>Some open source maintainers argue that it's futile to monitor metrics because it is easy to fudge the numbers, but we disagree.</p> <p>Fudging an individual metric in an undetectable manner is actually hard.  It's easy to buy GitHub stars, but hard to do so without triggering a fake stars algorithm.</p> <p>Gaming a whole basket of metrics would be quite challenging.  It would also be so obvious.  Each platform actively monitors fake activity and you'd likely get banned.</p> <p>You don't need to game your project metrics of course.  You should let your project metrics grow organically, so they give you an accurate reading on the state of your project.</p>"},{"location":"open-source/project-metrics/#number-of-new-contributors","title":"Number of new contributors","text":"<p>GitHub shows the total number of contributors and you can track the delta on a periodic basis.</p> <p>Although it's generally better to have more contributors, great projects can also be built with one or just a few developers.</p> <p>Many projects are written by 1-3 developers but have many contributors because of small PRs from the community. That's fine, too.</p> <p>A growing contributor base generally indicates 1. interest in the project, 2. engaged users, and 3. project maintainers that are merging community PRs.  More contributors are highly correlated with project health.</p>"},{"location":"open-source/project-metrics/#github-stars","title":"GitHub stars","text":"<p>The number of GitHub stars is correlated with project interest and usage.</p> <p>Developers star repos they find interesting or that they depend on.</p> <p>Projects with growing star counts are generally also growing.</p>"},{"location":"open-source/project-metrics/#linkedin-followers","title":"LinkedIn followers","text":"<p>Large projects should have a LinkedIn page where users can follow them and learn about new features. To build a following, you need to post regularly to the page.</p> <p>Don't start a LinkedIn page if your library is small or if you're not ready to post frequently.</p> <p>If you do have a LinkedIn page, tracking the number of followers is a good way to measure project growth.</p>"},{"location":"open-source/project-metrics/#project-downloads","title":"Project downloads","text":"<p>Project downloads are also a good way to measure project growth, although they are a flawed metric because most software downloads are bots.</p> <p>Some software artifact repositories, like PyPI, provide download numbers by operating system, which provide a more realistic number on how many individuals install a software project on a local laptop every day.</p> <p>Other software artifact repositories like Maven don't provide download information, so these metrics are not easily accessible.</p>"},{"location":"open-source/project-metrics/#number-of-open-issuesprs","title":"Number of open issues/PRs","text":"<p>Projects with lots of new issues and PRs are generally growing.</p> <p>Respond to issues/PRs quickly and help contributors merge their PRs to keep the project momentum high.</p> <p>It's good to track how many issues/PRs are created and closed to monitor the project growth and the quality of maintenance for the open source contributors.</p>"},{"location":"open-source/project-metrics/#documentation-page-views","title":"Documentation page views","text":"<p>The number of documentation page views and time spent on the page are correlated with a project's actual usage.</p> <p>If users spend a lot of time on your documentation pages, they are likely also using your software library a lot.</p> <p>It's best to use privacy-friendly analytics-gathering tools to measure user traffic. You don't need to collect any private user data; just gather the data necessary to provide your users with a great documentation experience.</p>"},{"location":"open-source/project-metrics/#conclusion","title":"Conclusion","text":"<p>Tracking metrics is a great way for the development team to fine-tune focus areas. If a project isn\u2019t getting enough new contributors, focus on creating more issues with the \u201cgood first issue\u201d label and responding to new contributors faster on GitHub.  If a project isn't getting enough downloads, focus on writing blog posts to highlight the cool features.</p> <p>Stay disiplined and track project metrics on a monthly or quarterly business.  Software engineers are generally interested in writing code and don't spend enough time community building and marketing cool features of their projects.  Metrics encourage you to focus on the weak parts of your project.</p>"}]}